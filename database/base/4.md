# 事物处理机制——乐观锁和悲观锁

### 锁

业务逻辑的实现过程中，往往需要保证数据访问的排他性。  
如在金融系统的日终结算处理中，希望针对某个cut-off时间点的数据进行处理，而不希望在结算过程中数据再发生变化。此时就需要通过一些机制来保证这些数据在某个操作过程中不会被外界修改。  
这种机制，在这里也就所谓的**锁**（Locking）：给选定的目标数据上锁，使其无法被其他程序修改。  

通常有两种锁：悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）。

### 悲观锁

对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。

悲观锁的实现，往往依靠数据库提供的锁机制。（也只有数据库层提供的锁机制才能真正保证数据访问的排他性）。

一个典型的依赖数据库的悲观锁调用：  
```
SELECT * FROM account WHERE name = "Eric" FOR UPDATE
```
这条记录锁定了account表中所有符合检索条件的记录。本次事务提交之前（事务提交时会释放事务过程的锁），外界无法修改这些记录。

### 乐观锁

相比于悲观锁，乐观锁机制采取更加宽松的加锁机制。

悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。  
如一个金融系统，某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如修改用户账户余额），若采用悲观锁机制，也就意味着真个给操作过程中，记录始终处于加锁状态。这样就无法面对高并发。

乐观锁机制在一定程度上解决了这个问题。  
乐观锁，大多数是基于数据版本（version）记录机制实现，即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个`version`字段来实现。

读数据时，将版本号一起读出。  
之后更新时，对版本号加一。  
此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行对比，若提交的数据版本号大于数据库当前版本号，则予以更新，否则认为是过期数据。
如：  
```
SELECT a.version, ... FROM account AS a WHERE addition...
...
UPDATE account SET version = version + 1 ... WHERE version =?... another addition
```
通过更新结果的行数来进行判断，如果为0，则说明记录被读取后以及被其他事务更改。

乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局限性。如来自外部系统的记录更新操作不受本系统的控制，可能会造成脏数据被更新到数据库。  
在系统设计阶段，就应该充分考虑到这些情况出现的可能性，并进行相应的调整（如 
将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 
径，而不是将数据库表直接对外公开）。

Hibernate在其数据访问引擎中内置了乐观锁的实现。如果检测到并发乐观锁异常，就抛出StableObjectStateException。  
```
public class Account {
  @Id
  private Long id;
  ...
  @Version
  Int version
  ...
}
```

### 典型的使用场景

悲观锁：并发情况下号码生成器（不能产生重复号码）的控制，先虚读当前序号，再根据当前序号更新。  
但对长事务来说，悲观锁的代价就非常大。此外，悲观锁使用不当会造成死锁，使用时应该避免。


Ref.:  
[事物处理机制---乐观锁（version详细使用）和悲观锁](http://blog.csdn.net/yansong_8686/article/details/39325429)
